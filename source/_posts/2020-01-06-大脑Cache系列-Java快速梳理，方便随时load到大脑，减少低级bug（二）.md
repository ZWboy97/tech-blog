---
title: '大脑Cache系列 -- Java快速梳理，方便随时load到大脑，减少低级bug（二） '
categories:
  - 技术
tags:
  - 未知
date: 2020-01-06 15:50:06
---

### 背景

> - Java程序常常会遇到一些蛋疼的bug，最后发现，都是在一些很基础的方面造成的。大量的时间花在调试代码找低级bug上是十分没有性价比的。所以，再系统梳理下Java，是十分必要的。
> - 已经反复学习和使用Java多次了，但只要有段时间没用Java之后，每次使用前都想要重头再梳理一遍。本文章将更注重Java只是的系统性，而不是细节性。
> - 本文是本人大脑的专属Cache，所以逻辑上可能只有我自己能够看懂，见谅。

### 一、目录
- Java继承
- Java反射
- Java接口
- Lambda表达式
- Java异常处理
- Java并发

<!--more-->

### 二、Java继承
##### Java与C++继承
- 子类 extends 父类，而C++是：符号
- Java只有公有继承，C++有公有继承和私有继承
- Java只支持单继承，多继承通过接口实现
- 子类从父类继承所有的数据域和方法，但有一些不一定能够访问到。
- 此外，子类只能通过覆盖来修改，以及增加方法，但绝对无法删除父类的任何方法和数据域。

##### 覆盖方法
- 覆盖：子类方法重写父类的方法，父类方法将会被覆盖，区别重载（本类方法之间）
- 覆盖时，子类和父类要严格一致（访问类型，返回值，方法名，参数列表）
  - 可以通过@Override来对子类的覆盖方法进行标记，来保障子类该方法成功覆盖了一个父类的方法，而不是定义了一个毫无相关的方法（没有匹配父类方法的时候，会编译报错）
- 被覆盖的父类方法依然可以通过super方法调用。
- super并不是像this那样是一个对象引用，**super只是一个指示编译器调用父类方法的特殊关键字，所以不能将super赋值给另一个变量。**
- super()调用父类的构造器

##### 多态与动态绑定
- 多态：父类对象变量可以引用子类对象，且能够通过父类对象正确调用该对象的方法。
- 动态绑定：在运行时，能够自动选择调用哪个方法。
- 用途：有一组不同类型的对象数据，可以直接通过他们父类类型的数组来统一组织
- 不能将父类引用赋值给子类变量，但是可以将子类引用赋值给父类对象，且不需要强制类型转换。

##### 方法调用的过程
- **对象在调用方法的时候，除了方法显式的参数之外，还有一个隐式参数，那便是对象本身，隐式参数不属于函数签名**
- 1.根据方法名，选出本类和父类中所有候选方法（父类中的方法需要是public的）
- 2.根据参数列表，进行重载解析，获得调用方法名字和参数类型，即函数签名（考虑子类覆盖父类）
- 3.如果该方法是private、static、final、或者构造器，那么编辑器就可以确定调用哪个方法了，这个称为静态绑定
- 4.可能存在多态的情况时，虚拟机会考虑到隐式参数对象的实际类型，选择调用对应类中的方法。依次实现运行时的动态绑定。

##### 阻止继承 final类和方法
- final类，不允许被继承
- final方法，子类不允许覆盖这个方法，final类中的所有方法都是final的。

##### 对象强制类型转换
- 只能在继承链上进行类型转换
- 在将父类转成子类之前，最好使用instanceof检查是否转换错误

```java
if(child instanceof Manager){ // 不需要判null
  manager = child;
}
```
- 在一些参数传递的时候可能会使用

##### 抽象类
- 为了进一步提升父类的通用能力
- 抽象类：含有一个或者多个抽象方法的类，就是抽象类
  - 抽象类和抽象方法需要使用abstract来修饰
  - 抽象类中是可以存在具体数据和具体方法的，可以存在一个抽象方法
- 抽象类是可以不包含抽象方法的
- **抽象类不能被实例化**，必须通过子类实现所有的抽象方法才可以。
- 虽然抽象类不能实例化，但可以通过抽象类变量引用子类对象（这是正常的父类子类特点）。

##### 受保护的访问
- private：仅对本类可见
- public：对所有类可见，无限制
- protected：对本类和子类，以及本包类可见
  - **如果想一个方法或者数据能够被子类访问，需要设置protected修饰符**
- 默认情况：对本包类可见，**对子类不可见**

| 修饰符 | 本类 | 本包 | 子类 | 其他包 |
|:----:|:----:|:----:|:----:|:----:|
| public | yes | yes |yes|yes|
| private |yes|no|no|no|
|protected|yes|yes|yes|no|
|default|yes|yes|**no**|no|

##### Object类
- 所有类的超类
- Java中只有基本类型不是对象，其他都是对象，都具有Object的方法和数据
- equals():判断两个对象是否是否有相同的引用（**同一个new出来的对象**）
  - **在没重写的情况下，与==的效果是一致的，判断的是不内容上的相等。**
  - String，Integer等类已经对equals()进行重写了。
  - 我们在实现自己类的时候，需要自己来实现equals。（很套路，很多IDE是支持一键自动生成的）
- Class getClass()：获得该对象所属于的类
  - class.getName获得类名
- hashcode(): 返回对象的散列值
  - 重要的是：**两个对象，如果equals为正，那么hashcode一定要保证相同**
  - Object中值为对象的存储地址(因为Object的equals就是判断地址的呀)
  - 字符串的散列码是由字符串内容导出的（因为String的equals参考了内容呀）
  - 一般的hashcode都是综合参考了存储地址和对象数据的
  - 因此**当自己实现equals的时候，对应的也要实现hashcode，来保证重要规则**
  - **两个相等的对象必须要返回相同的hashcode码，但是相等的hashcode不一定是相等的变量**，（再判断一下equals嘛）
  - java对象的hashcode设计是为了配合基于散列的集合,添加元素的时候，通过hashcode和equals来快速判断对象是否已经存在（比纯equals循环要好多了）
- toString():将对象以字符串形式输出，常用于日志之类。Object中默认的为类名+Hash值


##### 重写equals(Object obj)方法（了解即可，可以IDE自动生成的，hh）
- 1.引用的是同一个对象吗
- 2.obj为null吗？
- 3.两个是同一个类吗
- 4.obj强制转化成本类
- 5.一次判断各个数据域是否相等
- **记得还要检查下hashcode是否要也要重写哦**

