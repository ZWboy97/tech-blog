---
title: 'LeetCode Hot 100 刷题 [21-30]'
categories:
  - 算法
  - LeetCode
tags:
  - LeetCode
  - 算法
date: 2020-07-28 09:47:00
---


# LeetCode Hot 100 [11-20]

>刷完了《剑指Offer》，下一阶段，开始 LeetCode Hot 100。 之前一直都用思维导图记录，今天发现思维导图可以导出成markdown，简单编辑一下就可以成为文章。相比Xmind，博客文章打开和查看更加方便，所以之后每次Xmind记录之后，会再在这里同时同步一下

## 前言
HOT100，之前的文章传送门
[LeetCode Hot 100 刷题 [1-10]](http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot100-shua-ti-1-10.html)
[LeetCode Hot 100 刷题 [11-20]](http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot-100-shua-ti-11-20.html)

## 21.接雨水问题
### 题目
>- 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
- 输入: [0,1,0,2,1,0,1,3,2,1,2,1]
- 输出: 6
- [题目地址](https://leetcode-cn.com/problems/trapping-rain-water/)
- 这是一道Hard题	

### 解题思路
#### 思路1：暴力算法
- 按列，统计每个列上可以存的雨水的量
- 如何计算某个列上存水的量
    1. 遍历找出该列左边的最大高度，maxleft
	2. 遍历找出该列右边的最大高度，maxRight
	3. 水的高度取决于maxLeft和maxRight中的较小者
	4. 这个列上水的深度为水的高度 - 该列的高度
- 代码实现
```java
		public int trap(int[] height) {
        int res = 0;
        for(int i =0; i < height.length; i++){
            // find max left
            int leftMax = 0;
            for(int j = 0; j < i; j++){
                leftMax = Math.max(leftMax, height[j]);
            }
            // find max right
            int rightMax = 0;
            for(int j = i+1; j<height.length; j++){
                rightMax = Math.max(rightMax, height[j]);
            }
            int validHeight = Math.min(leftMax,rightMax);
            res += Math.max(0, validHeight-height[i]);
        }
        return res;
    }
```
- 算法复杂度
    - 时间复杂度O(N^2)

#### 思路2：动态规划
- 对思路1进行优化，思路1中查找左右最大值的过程可以通过DP优化
- 定义maxLeftDP[ i ] 为 i 左边的最大高度，同理，maxRightDp[ i ]为 i 右边的最大高度 
- maxLeftDP[ i ] = Max{ maxLeftDP[ i-1 ] , height[ i-1 ] }
- 代码实现
```java
	public int trap(int[] height) {
        int res = 0;
        int [] maxLeftDP = new int [height.length];
        int [] maxRightDP = new int [height.length];
        int size = height.length;
        for(int i = 1; i < size-1; i++){
            maxLeftDP[i] = Math.max(maxLeftDP[i-1], height[i-1]);
            maxRightDP[size-1- i] = Math.max(maxRightDP[ size-i], height[size-i]);
        }
        for(int i = 1; i < height.length-1; i++){
            int validHeight = Math.min(maxLeftDP[i],maxRightDP[i]);
            res += Math.max(0, validHeight-height[i]);
        }
        return res;
    }
```
- 复杂度分析
    - 时间复杂度O(N)
	- 空间复杂度O(N)

#### 思路3：双指针解法
- 对思路2中的空间复杂度还可以进一步优化
- DP递推方程中，maxLeft和maxRight其实只用到左右边的一个，其实可以不用数组来存储
- maxLeftDP是直接可以用变量来替代的，但是maxRightDP的求解是从右向左的，不方便直接用变量来替代
- 思路与过程
    - left、right双指针从两端进行更新
	- maxLeft、maxRight记录left和right位置对应的左右最大值
	- maxLeft和maxRight中，起作用的是他们中的较小值，所以每次left和right指针更新较小值的一端
- 如何选择更新哪一段
    - maxLeft < maxRight
	    - 可以保证maxLeft为left左边最大值，且它是起作用的
	    - left指针前进，同时更新maxleft
	maxLeft > maxRight
	    - 同理，可以保障maxRight为right右边最大值，且它比maxLeft要小，所以即便加上右边还没检查的部分，最终的maxLeft还是比maxRight大，即起作用的还是maxRight
		- 所以，right指针前进，同时更新maxRight
	- 让我想起了类似的用双指针求最大面积的题目
	    - 每次搜索高度较小的一边
- 代码实现
```java
	public int trap(int[] height) {
        int res = 0;
        int left = 0, right = height.length - 1;
        int maxLeft = 0, maxRight = 0;
        while( left <= right){
            // maxLeft 起作用
            if( height[left] < maxRight && maxLeft < maxRight ){
                if( height[left] > maxLeft ){
                    maxLeft = height[left];
                }else{
                    res += maxLeft - height[left];
                } 
                left++;
            } else { // maxRight 起作用
                if( height[right] > maxRight ){
                    maxRight = height[right];
                }else{
                    res += maxRight - height[right];
                } 
                right--;
            }
        }
        return res;
    }
```
- 复杂度分析
	- 时间复杂度O(N)
	- 空间复杂度O(1)

## 22.旋转图像
### 题目
>- 给定一个 n × n 的二维矩阵表示一个图像。
- 将图像顺时针旋转 90 度。
- 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
- 给定 matrix = 
```java
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
]
```
- 原地旋转输入矩阵，使其变为:
```java
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```
- [题目地址](https://leetcode-cn.com/problems/rotate-image)

### 解题思路
#### 思路1：转置+行交换
- 思路与过程
	1. 将行按照对称的方式进行交换
        - a[i][j] 与 a[ len-i-1 ][j]交换
	2. 将处理后的矩阵按对角进行转置
	    - a[i][j] 与 a[j][i]交换
- 代码实现
```java
	public void rotate(int[][] matrix) {
        // 水平交换
        int left = 0, right = matrix.length-1;

        while( left < right){
            for(int i = 0; i < matrix[0].length;i++){
                rowSwap(matrix, left, right, i);
            }
            left++;
            right--;
        }
        // 对角线对称
        for(int i = 0; i<matrix.length; i++){
            for(int j = 0; j< i; j++){
                angleSwap(matrix,i,j);
            }
        }
    }

    private void rowSwap(int [][] matrix, int left, int right , int i){
        int temp = matrix[left][i];
        matrix[left][i] = matrix[right][i];
        matrix[right][i] = temp;
    }

    private void angleSwap(int [][] matrix, int i, int j){
        int temp = matrix[i][j];
        matrix[i][j] = matrix[j][i];
        matrix[j][i] = temp;
    }
```
- 复杂度评估
    - 时间复杂度O(N^2)

## 下个路口见
HOT100依然在继续，写在下一篇文章中。[传送门]()
