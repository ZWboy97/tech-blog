---
title: 'LeetCode Hot 100 刷题 [21-30]'
categories:
  - 算法
  - LeetCode
tags:
  - LeetCode
  - 算法
date: 2020-07-28 09:47:00
---


# LeetCode Hot 100 [11-20]

>刷完了《剑指Offer》，下一阶段，开始 LeetCode Hot 100。 之前一直都用思维导图记录，今天发现思维导图可以导出成markdown，简单编辑一下就可以成为文章。相比Xmind，博客文章打开和查看更加方便，所以之后每次Xmind记录之后，会再在这里同时同步一下

## 前言
HOT100，之前的文章传送门
[LeetCode Hot 100 刷题 [1-10]](http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot100-shua-ti-1-10.html)
[LeetCode Hot 100 刷题 [11-20]](http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot-100-shua-ti-11-20.html)

## 21.接雨水问题
### 题目
>- 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
- 输入: [0,1,0,2,1,0,1,3,2,1,2,1]
- 输出: 6
- [题目地址](https://leetcode-cn.com/problems/trapping-rain-water/)
- 这是一道Hard题	

### 解题思路
#### 思路1：暴力算法
- 按列，统计每个列上可以存的雨水的量
- 如何计算某个列上存水的量
    1. 遍历找出该列左边的最大高度，maxleft
	2. 遍历找出该列右边的最大高度，maxRight
	3. 水的高度取决于maxLeft和maxRight中的较小者
	4. 这个列上水的深度为水的高度 - 该列的高度
- 代码实现
```java
		public int trap(int[] height) {
        int res = 0;
        for(int i =0; i < height.length; i++){
            // find max left
            int leftMax = 0;
            for(int j = 0; j < i; j++){
                leftMax = Math.max(leftMax, height[j]);
            }
            // find max right
            int rightMax = 0;
            for(int j = i+1; j<height.length; j++){
                rightMax = Math.max(rightMax, height[j]);
            }
            int validHeight = Math.min(leftMax,rightMax);
            res += Math.max(0, validHeight-height[i]);
        }
        return res;
    }
```
- 算法复杂度
    - 时间复杂度O(N^2)

#### 思路2：动态规划
- 对思路1进行优化，思路1中查找左右最大值的过程可以通过DP优化
- 定义maxLeftDP[ i ] 为 i 左边的最大高度，同理，maxRightDp[ i ]为 i 右边的最大高度 
- maxLeftDP[ i ] = Max{ maxLeftDP[ i-1 ] , height[ i-1 ] }
- 代码实现
```java
	public int trap(int[] height) {
        int res = 0;
        int [] maxLeftDP = new int [height.length];
        int [] maxRightDP = new int [height.length];
        int size = height.length;
        for(int i = 1; i < size-1; i++){
            maxLeftDP[i] = Math.max(maxLeftDP[i-1], height[i-1]);
            maxRightDP[size-1- i] = Math.max(maxRightDP[ size-i], height[size-i]);
        }
        for(int i = 1; i < height.length-1; i++){
            int validHeight = Math.min(maxLeftDP[i],maxRightDP[i]);
            res += Math.max(0, validHeight-height[i]);
        }
        return res;
    }
```
- 复杂度分析
    - 时间复杂度O(N)
	- 空间复杂度O(N)

#### 思路3：双指针解法
- 对思路2中的空间复杂度还可以进一步优化
- DP递推方程中，maxLeft和maxRight其实只用到左右边的一个，其实可以不用数组来存储
- maxLeftDP是直接可以用变量来替代的，但是maxRightDP的求解是从右向左的，不方便直接用变量来替代
- 思路与过程
    - left、right双指针从两端进行更新
	- maxLeft、maxRight记录left和right位置对应的左右最大值
	- maxLeft和maxRight中，起作用的是他们中的较小值，所以每次left和right指针更新较小值的一端
- 如何选择更新哪一段
    - maxLeft < maxRight
	    - 可以保证maxLeft为left左边最大值，且它是起作用的
	    - left指针前进，同时更新maxleft
	maxLeft > maxRight
	    - 同理，可以保障maxRight为right右边最大值，且它比maxLeft要小，所以即便加上右边还没检查的部分，最终的maxLeft还是比maxRight大，即起作用的还是maxRight
		- 所以，right指针前进，同时更新maxRight
	- 让我想起了类似的用双指针求最大面积的题目
	    - 每次搜索高度较小的一边
- 代码实现
```java
	public int trap(int[] height) {
        int res = 0;
        int left = 0, right = height.length - 1;
        int maxLeft = 0, maxRight = 0;
        while( left <= right){
            // maxLeft 起作用
            if( height[left] < maxRight && maxLeft < maxRight ){
                if( height[left] > maxLeft ){
                    maxLeft = height[left];
                }else{
                    res += maxLeft - height[left];
                } 
                left++;
            } else { // maxRight 起作用
                if( height[right] > maxRight ){
                    maxRight = height[right];
                }else{
                    res += maxRight - height[right];
                } 
                right--;
            }
        }
        return res;
    }
```
- 复杂度分析
	- 时间复杂度O(N)
	- 空间复杂度O(1)

## 22.旋转图像
### 题目
>- 给定一个 n × n 的二维矩阵表示一个图像。
- 将图像顺时针旋转 90 度。
- 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
- 给定 matrix = 
```java
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
]
```
- 原地旋转输入矩阵，使其变为:
```java
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```
- [题目地址](https://leetcode-cn.com/problems/rotate-image)

### 解题思路
#### 思路1：转置+行交换
- 思路与过程
	1. 将行按照对称的方式进行交换
        - a[i][j] 与 a[ len-i-1 ][j]交换
	2. 将处理后的矩阵按对角进行转置
	    - a[i][j] 与 a[j][i]交换
- 代码实现
```java
	public void rotate(int[][] matrix) {
        // 水平交换
        int left = 0, right = matrix.length-1;

        while( left < right){
            for(int i = 0; i < matrix[0].length;i++){
                rowSwap(matrix, left, right, i);
            }
            left++;
            right--;
        }
        // 对角线对称
        for(int i = 0; i<matrix.length; i++){
            for(int j = 0; j< i; j++){
                angleSwap(matrix,i,j);
            }
        }
    }

    private void rowSwap(int [][] matrix, int left, int right , int i){
        int temp = matrix[left][i];
        matrix[left][i] = matrix[right][i];
        matrix[right][i] = temp;
    }

    private void angleSwap(int [][] matrix, int i, int j){
        int temp = matrix[i][j];
        matrix[i][j] = matrix[j][i];
        matrix[j][i] = temp;
    }
```
- 复杂度评估
    - 时间复杂度O(N^2)

## 23.字母异位词分组  
### 题目
>- 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
- 输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
- 输出:
```java
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```		
- 所有输入均为小写字母。
- 不考虑答案输出的顺序。
- [题目地址](https://leetcode-cn.com/problems/group-anagrams/)

### 解题思路
#### 思路1：排序 + HashMap
- 对每一个字符串的字符按字典序进行排序
- 将排序后的结果作为HashMap的key，value为列表
- 最终将HashMap的values输出为列表
    - values()，返回的是数组，不是List，需要将数组转化成list
	- Java8 Stream API:`hashMap.values().stream().collect(Collectors.toList())`
	- Java8之前：`new ArrayList(hashMap.values())`
- 代码实现
```java
	public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> hashMap = new HashMap();
        for(String str : strs){
            char [] values = str.toCharArray();
            Arrays.sort(values);
            String key = new String(values);
            if(hashMap.containsKey(key)){
                hashMap.get(key).add(str);
            }else{
                List<String> list = new ArrayList();
                list.add(str);
                hashMap.put(key,list);
            }
        }
        return hashMap.values().stream().collect(Collectors.toList());
    }
```
- 复杂度分析
    - 时间复杂度O(Nklogk)
    - 空间复杂度O(NK)

#### 思路2：字符计数 + HashMap
- 与思路1基本类似，只是key的生成方式不一样
- 思路1需要排序，O(klogk)，还是比较高的
- 可以统计每个字符串中26个字母出现的次数，作为模式，模式作为hashmap的key
    - 计数模式：`int [ ] count = new int [26]`
    - 最后的模式串：`1#0#6#...`
- 代码实现
```java
	public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> hashMap = new HashMap();
        int [] count = new int [26];
        for(String str : strs){
            char [] values = str.toCharArray();
            Arrays.fill(count, 0);
            for(char ch : values){
                count[ch-'a']++;
            }
            StringBuilder builder = new StringBuilder();
            for(int num:count){
                builder.append(num);
                builder.append(',');
            }
            String key = builder.toString();
            if(hashMap.containsKey(key)){
                hashMap.get(key).add(str);
            }else{
                List<String> list = new ArrayList();
                list.add(str);
                hashMap.put(key,list);
            }
        }
        return hashMap.values().stream().collect(Collectors.toList());
    }
```
- 复杂度分析
    - 时间复杂度O(NK)
	- 空间复杂度O(NK)

## 24.跳跃游戏  
### 题目
>- 给定一个非负整数数组，你最初位于数组的第一个位置。
- 数组中的每个元素代表你在该位置可以跳跃的最大长度。
- 判断你是否能够到达最后一个位置。
- 输入: [2,3,1,1,4]
- 输出: true
- 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
- [题目地址](https://leetcode-cn.com/problems/jump-game/)

### 解题思路
#### 思路1：排除法
- 研究什么时候跳不到终点
    1. 序列中有 0 的时候，才会可能跳不到终点
	2. 当 0 前边所有的数都无法跳过 0 ，则必定跳不过去
	    - 即该位置的值，小于等于该位置距离0的格数
	3. 最后一个为0不影响
- 思路过程
1. 遍历数组，检索所有的0
    - 最后一个位置是否为0不影响，所以不用判断
2. 对每一个0， 向前遍历，是否存在能跳跃过它的数
3. 所有的都满足，则可以到达最后一个位置
- 代码实现
```java
	public boolean canJump(int[] nums) {        
        for(int i=0; i < nums.length-1; i++){
         // 最后一个是0还是非0对结果不影响
            if(nums[i] == 0){
                int j,dis=1;
                for(j = i-1; j >= 0; j--,dis++){
                    if(nums[j] > dis) break;
                }
                if(j < 0) return false;
            }
        }
        return true;
    }
```
- 复杂度分析
    - 时间复杂度O(N^2)
	- 空间复杂度O(1)

#### 思路2：贪心算法
- 是本题的最优解法，也应该是主要的考察点
- 比较不容易想到贪心规则
- 某一位置可达，则该位置之前的位置均是可达的
- 所以，只要保障能到达的位置超过数组最后一个位置就可以了
    - 因此，每次都尽可能的向远处跳
- 思路过程
1. mostFarIndex 标识目前能到达的最远位置
2. 当前位置在最远位置或之前，则说明最远位置可能还可以更大，更新最远位置
3. 若当前位置在最远位置之后了，则最远位置再也没法更新了，也就最终无法超越最后一个位置了

- 代码实现
```java
	public boolean canJump(int[] nums) {        
        int mostFarIndex = 0;
        for(int i=0; i < nums.length-1; i++){ // 最后一个不影响
            if( i <= mostFarIndex ){
                mostFarIndex = Math.max(mostFarIndex, i + nums[i]);
                if(mostFarIndex >= nums.length-1) return true;
            } else {
                return false;
            }
        }
        return mostFarIndex >= nums.length-1;
    }
```

- 复杂度分析
    - 时间复杂度O(N)
	- 空间复杂度O(1)

## 下个路口见
HOT100依然在继续，写在下一篇文章中。[传送门]()
